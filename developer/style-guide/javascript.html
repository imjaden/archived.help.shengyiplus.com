

<!DOCTYPE html>
<html lang="zh-CN">
  <head><meta name="generator" content="Hexo 3.9.0">
    <title>Javascript 编程规范 — 胜因学院</title>
    <meta charset="utf-8">
    <meta name="description" content="Vue.js - The Progressive JavaScript Framework">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <meta property="og:type" content="article">
    <meta property="og:title" content="Javascript 编程规范 — Vue.js">
    <meta property="og:description" content="Vue.js - The Progressive JavaScript Framework">
    <meta property="og:image" content="https://cn.vuejs.org//images/logo.png">

    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="Javascript 编程规范 — Vue.js">
    <meta name="twitter:description" content="Vue.js - The Progressive JavaScript Framework">
    <meta name="twitter:image" content="https://cn.vuejs.org/images/logo.png">

    <link rel="icon" href="/images/intfocus.png" type="image/png">

    <meta name="msapplication-TileColor" content="#4fc08d">
    <meta name="theme-color" content="#4fc08d">

    <meta name="msapplication-config" content="browserconfig.xml">
    <link rel="manifest" href="/manifest.json">

    <!-- <link href='//fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,600|Roboto Mono' rel='stylesheet' type='text/css'> -->
    <!-- <link href='//fonts.googleapis.com/css?family=Dosis:500&text=Vue.js' rel='stylesheet' type='text/css'> -->

    <link href="//code.bdstatic.com/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">

    <!-- main page styles -->
    <link rel="stylesheet" href="/css/page.css">

    <!-- this needs to be loaded before guide's inline scripts -->
    <script src="/js/vue.js"></script>
    <script>
      Vue.config.productionTip = false
      window.PAGE_TYPE = "Javascript 编程规范"
    </script>
  </head>
  <body class="docs">
    <div id="mobile-bar">
      <a class="menu-button"></a>
      <a class="logo" href="/"></a>
    </div>
    <div id="header">
  <a id="logo" href="/">
    <img src="/images/logo.png" alt="vue logo">
    <span>Intfocus</span>
  </a>
  <ul id="nav">
    <li>
  <form id="search-form">
    <input type="text" id="search-query-nav" class="search-query st-default-search-input">
  </form>
</li>
<li class="nav-dropdown-container learn">
  <a class="nav-link current">生态系统</a><span class="arrow"></span>
  <ul class="nav-dropdown">
    <li><h4>应用实例</h4></li>
    <li>
      <ul>
        <li><a href="/application/syp-wxmp.html" class="nav-link">胜因学院<small>(小程序)</small></a></li>
        <li><a href="/application/syp-android-tv.html" class="nav-link">胜因盒子<small>(TV大屏)</small></a></li>
      </ul>
    </li>
  </ul>
</li>

<li class="nav-dropdown-container learn">
  <a class="nav-link current">开发文档</a><span class="arrow"></span>
  <ul class="nav-dropdown">
    <li><h4>编程规范</h4></li>
    <li>
      <ul>
        <li><a href="/developer/style-guide/gitlab.html" class="nav-link">Gitlab</a></li>
        <li><a href="/developer/style-guide/java.html" class="nav-link">Java</a></li>
        <li><a href="/developer/style-guide/mysql.html" class="nav-link">MySQL</a></li>
        <li><a href="/developer/style-guide/javascript.html" class="nav-link current">Javascript</a></li>
      </ul>
    </li>
    <li><h4>开发规范</h4></li>
    <li>
      <ul>
        <li><a href="/developer/api-design-guide.html" class="nav-link">API 设计<small></small></a></li>
        <li><a href="/developer/rdc-guide.html" class="nav-link">RDC 接口<small></small></a></li>
        <li><a href="/developer/menu-guide.html" class="nav-link">业务菜单规范<small></small></a></li>
        <li><a href="/developer/database-devops-guide.html" class="nav-link">数据库运维<small></small></a></li>
      </ul>
    </li>
    <li><h4>接口文档</h4></li>
    <li>
      <ul>
        <li><a href="/developer/api-guide/syp-wxmp.html" class="nav-link">胜因学院<small>(小程序)</small></a></li>
        <li><a href="/developer/api-guide/datav-report.html" class="nav-link">DataV报表<small>(大屏)</small></a></li>
        <li><a href="/developer/api-guide/java-admin-add-module.html" class="nav-link">添加模块<small>(运营平台)</small></a></li>
      </ul>
    </li>
    <li><h4>项目源码</h4></li>
    <li>
      <ul>
        <li><a href="/developer/project-connections.html" class="nav-link">源码体系</a></li>
        <li><a href="/developer/sypctl-readme.html" class="nav-link">SypCtl 工具</a></li>
        <li><a href="/developer/jenkins-deploy.html" class="nav-link">Jenkins 部署</a></li>
      </ul>
    </li>
  </ul>
</li>

<li class="nav-dropdown-container learn">
  <a class="nav-link current">企业文化</a><span class="arrow"></span>
  <ul class="nav-dropdown">
    <li><h4>职场培训</h4></li>
    <li>
      <ul>
        <li><a href="/corporate-culture/workplace-ceremony.html" class="nav-link">职场共识</a></li>
        <li><a href="/corporate-culture/teamwork.html" class="nav-link">职场协作</a></li>
      </ul>
    </li>
    <li><h4>生命力</h4></li>
    <li>
      <ul>
        <li><a href="/corporate-culture/online-documents.html" class="nav-link">在线文档</a></li>
        <li><a href="/corporate-culture/weekly-publication.html" class="nav-link">胜因周刊</a></li>
      </ul>
    </li>
  </ul>
</li>

<li>
  <a href="https://intfocus.com" target="_blank" class="nav-link team">官网</a>
</li>

  </ul>
</div>

    
    
      <div id="main" class="fix-sidebar">
        
          
  <div class="sidebar">
  <div class="sidebar-inner">
    <ul class="main-menu">
      <li>
  <form id="search-form">
    <input type="text" id="search-query-sidebar" class="search-query st-default-search-input">
  </form>
</li>
<li class="nav-dropdown-container learn">
  <a class="nav-link current">生态系统</a><span class="arrow"></span>
  <ul class="nav-dropdown">
    <li><h4>应用实例</h4></li>
    <li>
      <ul>
        <li><a href="/application/syp-wxmp.html" class="nav-link">胜因学院<small>(小程序)</small></a></li>
        <li><a href="/application/syp-android-tv.html" class="nav-link">胜因盒子<small>(TV大屏)</small></a></li>
      </ul>
    </li>
  </ul>
</li>

<li class="nav-dropdown-container learn">
  <a class="nav-link current">开发文档</a><span class="arrow"></span>
  <ul class="nav-dropdown">
    <li><h4>编程规范</h4></li>
    <li>
      <ul>
        <li><a href="/developer/style-guide/gitlab.html" class="nav-link">Gitlab</a></li>
        <li><a href="/developer/style-guide/java.html" class="nav-link">Java</a></li>
        <li><a href="/developer/style-guide/mysql.html" class="nav-link">MySQL</a></li>
        <li><a href="/developer/style-guide/javascript.html" class="nav-link current">Javascript</a></li>
      </ul>
    </li>
    <li><h4>开发规范</h4></li>
    <li>
      <ul>
        <li><a href="/developer/api-design-guide.html" class="nav-link">API 设计<small></small></a></li>
        <li><a href="/developer/rdc-guide.html" class="nav-link">RDC 接口<small></small></a></li>
        <li><a href="/developer/menu-guide.html" class="nav-link">业务菜单规范<small></small></a></li>
        <li><a href="/developer/database-devops-guide.html" class="nav-link">数据库运维<small></small></a></li>
      </ul>
    </li>
    <li><h4>接口文档</h4></li>
    <li>
      <ul>
        <li><a href="/developer/api-guide/syp-wxmp.html" class="nav-link">胜因学院<small>(小程序)</small></a></li>
        <li><a href="/developer/api-guide/datav-report.html" class="nav-link">DataV报表<small>(大屏)</small></a></li>
        <li><a href="/developer/api-guide/java-admin-add-module.html" class="nav-link">添加模块<small>(运营平台)</small></a></li>
      </ul>
    </li>
    <li><h4>项目源码</h4></li>
    <li>
      <ul>
        <li><a href="/developer/project-connections.html" class="nav-link">源码体系</a></li>
        <li><a href="/developer/sypctl-readme.html" class="nav-link">SypCtl 工具</a></li>
        <li><a href="/developer/jenkins-deploy.html" class="nav-link">Jenkins 部署</a></li>
      </ul>
    </li>
  </ul>
</li>

<li class="nav-dropdown-container learn">
  <a class="nav-link current">企业文化</a><span class="arrow"></span>
  <ul class="nav-dropdown">
    <li><h4>职场培训</h4></li>
    <li>
      <ul>
        <li><a href="/corporate-culture/workplace-ceremony.html" class="nav-link">职场共识</a></li>
        <li><a href="/corporate-culture/teamwork.html" class="nav-link">职场协作</a></li>
      </ul>
    </li>
    <li><h4>生命力</h4></li>
    <li>
      <ul>
        <li><a href="/corporate-culture/online-documents.html" class="nav-link">在线文档</a></li>
        <li><a href="/corporate-culture/weekly-publication.html" class="nav-link">胜因周刊</a></li>
      </ul>
    </li>
  </ul>
</li>

<li>
  <a href="https://intfocus.com" target="_blank" class="nav-link team">官网</a>
</li>

    </ul>
    <div class="list">
      
      
        <h2>
          
          
          
        </h2>
        <ul class="menu-root">
  
    
    
    <li>
      <a href="/developer/style-guide/javascript.html" class="sidebar-link current">Javascript 编程规范</a>
    </li>
  
</ul>

      
    </div>
  </div>
</div>

<!--
<div id="sidebar-sponsors-platinum-right">
  <div class="main-sponsor">
    <span>白金赞助商</span>
    <div>
    <a href="https://bit.dev/?utm_source=vue&utm_medium=vue&utm_campaign=vue&utm_term=vue&utm_content=vue" target="_blank" class="logo">
      <img src="/images/bit.png" alt="Bit">
    </a>
    <a href="http://tooltwist.com/" target="_blank" class="logo">
      <img src="/images/tooltwist.png" alt="Tooltwist">
    </a>
    <a href="https://vueschool.io/?utm_source=Vuejs.org&utm_medium=Banner&utm_campaign=Sponsored%20Banner&utm_content=V1" target="_blank" class="logo">
      <img src="/images/vueschool.png" alt="VueSchool">
    </a>
    <a href="https://vehikl.com/" target="_blank" class="logo">
      <img src="/images/vehikl.png" alt="Vehikl">
    </a>
    <a href="https://www.nativescript.org/vue?utm_source=vue-js-org&utm_medium=website&utm_campaign=nativescript-awareness" target="_blank" class="logo">
      <img src="/images/nativescript.png" alt="NativeScript">
    </a>
    <a href="https://teeplusplusclth.com/" target="_blank" class="logo">
      <img src="/images/tee__.png" alt="Tee++">
    </a>
    </div>
  </div>
  <a class="become-backer" href="/support-vuejs">
    成为赞助者
  </a>
</div>

-->


<div class="content Javascript 编程规范 with-sidebar ">
  
    
      
    
  
  
    <h1>Javascript 编程规范</h1>
  

  

  
    <h2 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h2><ul>
<li>标准变量采用驼峰式命名</li>
<li>ID 在变量名中全大写</li>
<li>常量全大写，用下划线连接构造函数，大写第一个字母</li>
<li>JQuery 对象必须以 $ 开头命名</li>
</ul>
<pre><code class="hljs undefined">let thisIsMyName;
let goodID;
let reportURL;
let AndroidVersion;
let iOSVersion;
let MAX_COUNT = 10;

function Person(name) &#123;
    this.name = name;
&#125;
// 不推荐
let body = $(&apos;body&apos;);
// 推荐
let $body = $(&apos;body&apos;);</code></pre>
<h2 id="函数命名"><a href="#函数命名" class="headerlink" title="函数命名"></a>函数命名</h2><blockquote>
<p>小驼峰命名法，可使用常见动词约定：</p>
</blockquote>
<ul>
<li><code>{ctl}{Event}</code>, 控件的操作事件，示例: <code>radioChange</code>, <code>btnSaveClick</code></li>
<li>canXXX 判断是否可执行某个动作，函数返回布尔值。true：可执行；false：不可执行</li>
<li>hasXXX 判断是否含有某个值， 函数返回布尔值。true：含有此值；false：不含有此值</li>
<li>isXXX 判断是否为某个值，函数返回布尔值。true：为某个值；false：不为某个值</li>
<li>getXXX 获取某个值，函数返回非布尔值</li>
<li>setXXX 设置某个值<ul>
<li>无返回值</li>
<li>返回是否设置成功</li>
<li>返回链式对象 load 加载某些数据</li>
<li>返回是否加载完成的结果</li>
</ul>
</li>
</ul>
<pre><code class="hljs undefined">// 是否有权限
function hasPermission() &#123;
 return true;
&#125;
// 获取权限列表
function getPermissinList() &#123;
 return this.permissinList;
&#125;</code></pre>
<h2 id="引用-References"><a href="#引用-References" class="headerlink" title="引用 References"></a>引用 References</h2><ol>
<li><p>对所有的引用使用 const；不要使用 var。</p>
<blockquote>
<p>eslint: prefer-const, no-const-assign</p>
</blockquote>
<p>这可以确保你无法对引用重新分配，重新分配可能会导致 bug 和难以理解的代码。</p>
<pre><code class="hljs undefined">// 批评
var a = 1;
var b = 2;
// 推荐
const a = 1;
const b = 2;</code></pre>
</li>
<li><p>如果一定需要可变动的引用，使用 let 代替 var 。</p>
<blockquote>
<p>eslint: no-var jscs: disallowVar</p>
</blockquote>
<pre><code class="hljs undefined">// 不推荐
var count = 1;
if (true) &#123;
    count += 1;
&#125;
// 推荐
let count = 1;
if (true) &#123;
    count += 1;
&#125;</code></pre>
</li>
</ol>
<h2 id="对象-Objects"><a href="#对象-Objects" class="headerlink" title="对象 Objects"></a>对象 Objects</h2><ol>
<li><p>使用字面量语法创建对象。</p>
<blockquote>
<p>eslint: no-new-object</p>
</blockquote>
<pre><code class="hljs undefined">// 不推荐
const item = new Object();
// 推荐
const item = &#123;&#125;;</code></pre>
</li>
<li><p>创建带有动态属性名称的对象时使用计算的属性名称。</p>
<p>它们允许你在一个地方定义一个对象的所有属性。</p>
<pre><code class="hljs undefined">function getKey(k) &#123;
    return `a-key-named-k`;
&#125;
// 不推荐
const obj = &#123;
    id: 5,
    name: &apos;San Francisco&apos;,
&#125;;
obj[getKey(&apos;enabled&apos;)] = true;

// 推荐
const obj = &#123;
    id: 5,
    name: &apos;San Francisco&apos;,
    [getKey(&apos;enabled&apos;)]: true,
&#125;;</code></pre>
</li>
<li><p>使用对象方法速记语法。</p>
<blockquote>
<p>eslint: object-shorthand jscs: requireEnhancedObjectLiterals</p>
</blockquote>
<pre><code class="hljs undefined">// 不推荐
const atom = &#123;
  value: 1,
  addValue: function (value) &#123;
      return atom.value + value;
  &#125;
&#125;;

// 推荐
const atom = &#123;
  value: 1,
  addValue(value) &#123;
      return atom.value + value;
  &#125;
&#125;;</code></pre>
</li>
<li><p>使用对象属性速记语法。</p>
<blockquote>
<p>eslint: object-shorthand jscs: requireEnhancedObjectLiterals</p>
</blockquote>
<pre><code class="hljs undefined">const lukeSkywalker = &apos;Luke Skywalker&apos;;
// 不推荐
const obj = &#123;
    lukeSkywalker: lukeSkywalker,
&#125;;

// 推荐
const obj = &#123;
    lukeSkywalker,
&#125;;</code></pre>
</li>
<li><p>将速记属性分组写在对象声明的开始处</p>
<p>更容易看出哪些属性在使用速记语法</p>
<pre><code class="hljs undefined">const anakinSkywalker = &apos;Anakin Skywalker&apos;;
const lukeSkywalker = &apos;Luke Skywalker&apos;;
// 不推荐
const obj = &#123;
    episodeOne: 1,
    twoJediWalkIntoACantina: 2,
    lukeSkywalker,
    episodeThree: 3,
    mayTheFourth: 4,
    anakinSkywalker,
&#125;;
// 推荐
const obj = &#123;
    lukeSkywalker,
    anakinSkywalker,
    episodeOne: 1,
    twoJediWalkIntoACantina: 2,
    episodeThree: 3,
    mayTheFourth: 4,
&#125;;</code></pre>
</li>
<li><p>仅无效标识符的属性使用引号</p>
<blockquote>
<p>eslint: quote-props jscs: disallowQuotedKeysInObjects</p>
</blockquote>
<p>比较容易阅读。它改进了语法高亮显示，并且更容易被许多JS引擎优化。</p>
<pre><code class="hljs undefined">// 不推荐
const bad = &#123;
    &apos;foo&apos;: 3,
    &apos;bar&apos;: 4,
    &apos;data-blah&apos;: 5
&#125;;

// 推荐
const good = &#123;
    foo: 3,
    bar: 4,
    &apos;data-blah&apos;: 5
&#125;;</code></pre>
</li>
<li><p>用对象展开操作符浅复制对象，优先于Object.assign。</p>
<p>使用对象剩余操作符来获得一个省略某些属性的新对象。</p>
<pre><code class="hljs undefined">// 批评
const original = &#123; a: 1, b: 2 &#125;;
const copy = Object.assign(original, &#123; c: 3 &#125;); //  `original` 是可变的
delete copy.a; // so does this

// 不推荐
const original = &#123; a: 1, b: 2 &#125;;
const copy = Object.assign(&#123;&#125;, original, &#123; c: 3 &#125;); // copy =&gt; &#123; a: 1, b: 2, c: 3 &#125;

// 推荐
const original = &#123; a: 1, b: 2 &#125;;
const copy = &#123; ...original, c: 3 &#125;; // copy =&gt; &#123; a: 1, b: 2, c: 3 &#125;
const &#123; a, ...noA &#125; = copy; // noA =&gt; &#123; b: 2, c: 3 &#125;</code></pre>
</li>
</ol>
<h2 id="数组-Arrays"><a href="#数组-Arrays" class="headerlink" title="数组 Arrays"></a>数组 Arrays</h2><ol>
<li><p>使用字面量创建数组。</p>
<blockquote>
<p>eslint: no-array-constructor</p>
</blockquote>
<pre><code class="hljs undefined">// 不推荐
const items = new Array();
// 推荐
const items = [];</code></pre>
</li>
<li><p>使用数组展开操作符<code>...</code>复制数组。</p>
<pre><code class="hljs undefined">// 不推荐
const len = items.length;
const itemsCopy = [];
let i;
for (i = 0; i &lt; len; i += 1) &#123;
    itemsCopy[i] = items[i];
&#125;

// 推荐
const itemsCopy = [...items];</code></pre>
</li>
<li><p>使用展开操作符<code>...</code>代替 Array.from，将类数组(array-like) 对象转换成数组。</p>
<pre><code class="hljs undefined">const foo = document.querySelectorAll(&apos;.foo&apos;);
// 推荐
const nodes = Array.from(foo);
// 高效
const nodes = [...foo];</code></pre>
</li>
<li><p>使用 Array.from 代替展开操作符<code>...</code>来映射迭代，它避免了创建媒介数组。</p>
<pre><code class="hljs undefined">// 不推荐
const baz = [...foo].map(bar);
// 推荐
const baz = Array.from(foo, bar);</code></pre>
</li>
</ol>
<h2 id="解构-Destructuring"><a href="#解构-Destructuring" class="headerlink" title="解构 Destructuring"></a>解构 Destructuring</h2><ol>
<li><p>当访问和使用对象的多个属性时，请使用对象解构。</p>
<blockquote>
<p>eslint: prefer-destructuring jscs: requireObjectDestructuring</p>
</blockquote>
<pre><code class="hljs undefined">// 不推荐
function getFullName(user) &#123;
    const firstName = user.firstName;
    const lastName = user.lastName;
    return `firstName lastName`;
&#125;
// 推荐
function getFullName(user) &#123;
    const &#123; firstName, lastName &#125; = user;
    return `firstName lastName`;
&#125;
// 高效
function getFullName(&#123; firstName, lastName &#125;) &#123;
    return `firstName lastName`;
&#125;</code></pre>
</li>
<li><p>使用数组解构。</p>
<blockquote>
<p>eslint: prefer-destructuring jscs: requireArrayDestructuring</p>
</blockquote>
<pre><code class="hljs undefined">const arr = [1, 2, 3, 4];
// 不推荐
const first = arr[0];
const second = arr[1];
// 推荐
const [first, second] = arr;
const [first, second, ...other] = arr;</code></pre>
</li>
<li><p>使用对象解构来实现多个返回值，而不是数组解构。</p>
<p>随着时间的推移添加新的属性或更改排序，而不会改变调用时的位置。</p>
<pre><code class="hljs undefined">// 不推荐
function processInput(input) &#123;
    return [left, right, top, bottom];
&#125;
const [left, __, top] = processInput(input); // 需考虑返回数据的顺序

// 推荐
function processInput(input) &#123;
    return &#123; left, right, top, bottom &#125;;
&#125;
const &#123; left, top &#125; = processInput(input); // 只选择需要的数据</code></pre>
</li>
</ol>
<h2 id="字符串-Strings"><a href="#字符串-Strings" class="headerlink" title="字符串 Strings"></a>字符串 Strings</h2><ol>
<li><p>字符串使用单引号 ‘’。</p>
<blockquote>
<p>eslint: quotes jscs: validateQuoteMarks</p>
</blockquote>
<pre><code class="hljs undefined">// 不推荐
const name = &quot;Capt. Janeway&quot;;
// 不推荐 - 模板字面量应该包含插值或换行符
const name = `Capt. Janeway`;
// 推荐
const name = &apos;Capt. Janeway&apos;;</code></pre>
</li>
<li><p>构建字符串时，使用模板字符串。</p>
<blockquote>
<p>eslint: prefer-template template-curly-spacing jscs: requireTemplateStrings</p>
</blockquote>
<pre><code class="hljs undefined">// 不推荐
function sayHi(name) &#123;
    return &apos;How are you, &apos; + name + &apos;?&apos;;
&#125;
// 不推荐
function sayHi(name) &#123;
    return [&apos;How are you, &apos;, name, &apos;?&apos;].join();
&#125;
// 不推荐
function sayHi(name) &#123;
    return `How are you, $&#123; name &#125;?`;
&#125;
// 推荐
function sayHi(name) &#123;
     return `How are you, $&#123;name&#125;?`;
&#125;</code></pre>
</li>
<li><p>永远不要在字符串上使用 eval() ，它会打开太多的漏洞。</p>
<blockquote>
<p>eslint: no-eval</p>
</blockquote>
</li>
</ol>
<h2 id="函数-Functions"><a href="#函数-Functions" class="headerlink" title="函数 Functions"></a>函数 Functions</h2><ol>
<li><p>使用命名函数表达式而不是函数声明。</p>
<blockquote>
<p>eslint: func-style jscs: disallowFunctionDeclarations</p>
</blockquote>
<p>函数声明很容易被提升（Hoisting）,这对可读性和可维护性来说都是不利的;</p>
<pre><code class="hljs undefined">// 不推荐
function foo() &#123;
  // ...
&#125;
// 不推荐
const foo = function () &#123;
  // ...
&#125;;
// 推荐
// 用明显区别于变量引用调用的词汇命名
const short = function longUniqueMoreDescriptiveLexicalFoo() &#123;
  // ...
&#125;;</code></pre>
</li>
<li><p>用圆括号包裹立即调用函数表达式 (IIFE)。</p>
<blockquote>
<p>eslint: wrap-iife jscs: requireParenthesesAroundIIFE</p>
</blockquote>
<p>一个立即调用函数表达式是一个单独的单元 – 将函数表达式包裹在括号中，后面再跟一个调用括号，这看上去很紧凑。</p>
<pre><code class="hljs undefined">// 立即调用函数表达式 (IIFE)
(function () &#123;
  console.log(&apos;Welcome to the Internet. Please follow me.&apos;);
&#125;());</code></pre>
</li>
<li><p>不要使用 arguments。可以选择 rest 语法 <code>...</code> 替代。</p>
<p>使用 <code>...</code> 能明确要传入的参数。另外 rest（剩余）参数是一个真正的数组，而 arguments 是一个类数组（Array-like）。</p>
<pre><code class="hljs undefined">// 不推荐
function concatenateAll() &#123;
  const args = Array.prototype.slice.call(arguments);
  return args.join(&apos;&apos;);
&#125;
// 推荐
function concatenateAll(...args) &#123;
  return args.join(&apos;&apos;);
&#125;</code></pre>
</li>
<li><p>使用默认参数语法，而不要使用一个变化的函数参数</p>
<pre><code class="hljs undefined">// 不推荐
function handleThings(opts) &#123;
  // 更加糟糕: 如果参数 opts 是 falsy(假值) 的话，它将被设置为一个对象，
  // 这可能是你想要的，但它可以引起一些小的错误。
  opts = opts || &#123;&#125;;
  // ...
&#125;
// 不推荐
function handleThings(opts) &#123;
  if (opts === void 0) &#123;
      opts = &#123;&#125;;
  &#125;
  // ...
&#125;
// 推荐
function handleThings(opts = &#123;&#125;) &#123;
  // ...
&#125;</code></pre>
</li>
<li><p>始终将默认参数放在最后。</p>
<pre><code class="hljs undefined">// 不推荐
function handleThings(opts = &#123;&#125;, name) &#123;
  // ...
&#125;
// 推荐
function handleThings(name, opts = &#123;&#125;) &#123;
  // ...
&#125;</code></pre>
</li>
<li><p>隔开函数签名，括号两边用空格隔开。</p>
<pre><code class="hljs undefined">// 不推荐
const f = function()&#123;&#125;;
const g = function ()&#123;&#125;;
const h = function() &#123;&#125;;
// 推荐
const x = function () &#123;&#125;;
const y = function a() &#123;&#125;;</code></pre>
</li>
<li><p>不要改变参数(?)。</p>
<blockquote>
<p>eslint: no-param-reassign</p>
</blockquote>
<p><em>操作</em>作为参数传入的对象，可能会在调用原始对象时造成不必要的变量副作用。（对象是引用类型）</p>
<pre><code class="hljs undefined">// 不推荐
function f1(obj) &#123;
    obj.key = 1;
&#125;
// 推荐
function f2(obj) &#123;
    const key = Object.prototype.hasOwnProperty.call(obj, &apos;key&apos;) ? obj.key : 1;
&#125;</code></pre>
</li>
</ol>
<h2 id="箭头函数-Arrow-Functions"><a href="#箭头函数-Arrow-Functions" class="headerlink" title="箭头函数 Arrow Functions"></a>箭头函数 Arrow Functions</h2><ol>
<li><p>当必须使用匿名函数（如在传递一个内联回调时），请使用箭头函数表示法。</p>
<blockquote>
<p>eslint: prefer-arrow-callback, arrow-spacing jscs: requireArrowFunctions</p>
</blockquote>
<p>它创建了一个在 this 上下文中执行的函数的版本，这通常是你想要的，而且这样的写法更为简洁。</p>
<pre><code class="hljs undefined">// 不推荐
[1, 2, 3].map(function (x) &#123;
    const y = x + 1;
    return x * y;
&#125;);
// 不推荐
[1, 2, 3].map( _ =&gt; &#123;

    return 0;
&#125;);
// 推荐
[1, 2, 3].map((x) =&gt; &#123;
    const y = x + 1;
    return x * y;
&#125;);
// 推荐
[1, 2, 3].map(() =&gt; &#123;
    return 0;
&#125;);</code></pre>
</li>
<li><p>无副作用的单行语句</p>
<p>如果函数体由一个返回无副作用(side effect)的expression(表达式)的单行语句组成，那么可以省略大括号并使用隐式返回。否则，保留大括号并使用 return 语句</p>
<pre><code class="hljs undefined">// 不推荐
[1, 2, 3].map(number =&gt; &#123;
    const nextNumber = number + 1;
    return `A string containing the $&#123;nextNumber&#125;.`;
&#125;);
// 推荐
[1, 2, 3].map(number =&gt; `A string containing the $&#123;number&#125;.`);</code></pre>
</li>
<li><p>如果表达式跨多行，将其包裹在括号中，可以提高可读性。</p>
<pre><code class="hljs undefined">// 不推荐
[&apos;get&apos;, &apos;post&apos;, &apos;put&apos;].map(httpMethod =&gt; Object.prototype.hasOwnProperty.call(
    httpMagicObjectWithAVeryLongName,
    httpMethod
  )
);
// 推荐
[&apos;get&apos;, &apos;post&apos;, &apos;put&apos;].map(httpMethod =&gt; (
    Object.prototype.hasOwnProperty.call(
      httpMagicObjectWithAVeryLongName,
      httpMethod
    )
  )
);</code></pre>
</li>
<li><p>如果函数只有一个参数并且不使用大括号，则可以省略参数括号。否则，为了清晰和一致性，总是给参数加上括号。</p>
<pre><code class="hljs undefined">// 不推荐
[1, 2, 3].map((x) =&gt; x * x);
// 推荐
[1, 2, 3].map(x =&gt; x * x);
// 推荐
[1, 2, 3].map(number =&gt; (
  `A long string with the number. It’s so long that we don’t want it to take up space on the .map line!`
));
// 不推荐
[1, 2, 3].map(x =&gt; &#123;
  const y = x + 1;
  return x * y;
&#125;);
// 推荐
[1, 2, 3].map((x) =&gt; &#123;
  const y = x + 1;
  return x * y;
&#125;);</code></pre>
</li>
<li><p>避免使用比较运算符(&lt; =, &gt;=)时，混淆箭头函数语法(=&gt;)。</p>
<pre><code class="hljs undefined">// 不推荐
const itemHeight = item =&gt; item.height &gt; 256 ? item.largeSize : item.smallSize;
// 不推荐
const itemHeight = (item) =&gt; item.height &gt; 256 ? item.largeSize : item.smallSize;
// 推荐
const itemHeight = item =&gt; (item.height &gt; 256 ? item.largeSize : item.smallSize);
// 推荐
const itemHeight = (item) =&gt; &#123;
  const &#123; height, largeSize, smallSize &#125; = item;
  return height &gt; 256 ? largeSize : smallSize;
&#125;;</code></pre>
</li>
</ol>
<h2 id="类-Classes-amp-构造函数-Constructors"><a href="#类-Classes-amp-构造函数-Constructors" class="headerlink" title="类 Classes &amp; 构造函数 Constructors"></a>类 Classes &amp; 构造函数 Constructors</h2><ol>
<li><p>总是使用 class。避免直接操作 prototype 。</p>
<pre><code class="hljs undefined">// 不推荐
function Queue(contents = []) &#123;
    this.queue = [...contents];
&#125;
Queue.prototype.pop = function () &#123;
    const value = this.queue[0];
    this.queue.splice(0, 1);
    return value;
&#125;;
// 推荐
class Queue &#123;
    constructor(contents = []) &#123;
        this.queue = [...contents];
    &#125;
    pop() &#123;
        const value = this.queue[0];
        this.queue.splice(0, 1);
        return value;
    &#125;
&#125;</code></pre>
</li>
<li><p>使用 extends 继承。</p>
<p>extends 是一个内置的原型继承方法并且不会破坏 instanceof。</p>
<pre><code class="hljs undefined">// 不推荐
const inherits = require(&apos;inherits&apos;);
    function PeekableQueue(contents) &#123;
    Queue.apply(this, contents);
&#125;

inherits(PeekableQueue, Queue);
PeekableQueue.prototype.peek = function () &#123;
    return this.queue[0];
&#125;;

// 推荐
class PeekableQueue extends Queue &#123;
    peek() &#123;
        return this.queue[0];
    &#125;
&#125;</code></pre>
</li>
<li><p>如果没有指定，类有一个默认的构造函数。一个空的构造函数或者只是委托给父类则不是必须的(?)。</p>
<blockquote>
<p>eslint: no-useless-constructor</p>
</blockquote>
<pre><code class="hljs undefined">// 不推荐
class Jedi &#123;
    constructor() &#123;&#125;
        getName() &#123;
        return this.name;
    &#125;
&#125;
// 不推荐
class Rey extends Jedi &#123;
    constructor(...args) &#123;
        super(...args);
    &#125;
&#125;
// 推荐
class Rey extends Jedi &#123;
    constructor(...args) &#123;
        super(...args);
        this.name = &apos;Rey&apos;;
    &#125;
&#125;</code></pre>
</li>
<li><p>避免重复类成员(?)。</p>
<blockquote>
<p>eslint: no-dupe-class-members</p>
</blockquote>
<pre><code class="hljs undefined">// 不推荐
class Foo &#123;
  bar() &#123; return 1; &#125;
  bar() &#123; return 2; &#125;
&#125;
// 推荐
class Foo &#123;
  bar() &#123; return 1; &#125;
&#125;
// 推荐
class Foo &#123;
  bar() &#123; return 2; &#125;
&#125;</code></pre>
</li>
</ol>
<h2 id="模块-Modules"><a href="#模块-Modules" class="headerlink" title="模块 Modules"></a>模块 Modules</h2><ol>
<li><p>使用模块 (import/export) 而不是其他非标准模块系统。</p>
<pre><code class="hljs undefined">// 不推荐
const JavascriptStyleGuide = require(&apos;./JavascriptStyleGuide&apos;);
module.exports = JavascriptStyleGuide.es6;
// 一般
import JavascriptStyleGuide from &apos;./JavascriptStyleGuide&apos;;
export default JavascriptStyleGuide.es6;
// 推荐
import &#123; es6 &#125; from &apos;./JavascriptStyleGuide&apos;;
export default es6;</code></pre>
</li>
<li><p>不要使用通配符 import(导入)。</p>
<p>这样能确保你只有一个默认 export(导出)。</p>
<pre><code class="hljs undefined">// 不推荐
import * as JavascriptStyleGuide from &apos;./JavascriptStyleGuide&apos;;
// 推荐
import JavascriptStyleGuide from &apos;./JavascriptStyleGuide&apos;;</code></pre>
</li>
<li><p>不要从 import(导入) 中直接 export(导出)。</p>
<p>虽然一行代码简洁明了，但有一个明确的 import(导入) 方法和一个明确的 export(导出) 方法，使事情能保持一致。</p>
<pre><code class="hljs undefined">// 不推荐
export &#123; es6 as default &#125; from &apos;./JavascriptStyleGuide&apos;;

// 推荐
import &#123; es6 &#125; from &apos;./JavascriptStyleGuide&apos;;
export default es6;</code></pre>
</li>
<li><p>一个地方只在一个路径中 import(导入) 。</p>
<pre><code class="hljs undefined">// 不推荐
import foo from &apos;foo&apos;;
import &#123; named1, named2 &#125; from &apos;foo&apos;;

// 推荐
import foo, &#123; named1, named2 &#125; from &apos;foo&apos;;</code></pre>
</li>
<li><p>不要 export(导出) 可变绑定。</p>
<blockquote>
<p>eslint: import/no-mutable-exports</p>
</blockquote>
<p>一般应该避免可变性，特别是在导出可变绑定时。虽然一些特殊情况下，可能需要这种技术，但是一般而言，只应该导出常量引用。</p>
<pre><code class="hljs undefined">// 不推荐
let foo = 3;
export &#123; foo &#125;;
// 推荐
const foo = 3;
export &#123; foo &#125;;</code></pre>
</li>
<li><p>在只有单个导出的模块中，默认 export(导出) 优于命名 export(导出)。</p>
<blockquote>
<p>eslint: import/prefer-default-export</p>
</blockquote>
<p>为了鼓励更多的文件只有一个 export(导出)，这有利于模块的可读性和可维护性。</p>
<pre><code class="hljs undefined">// 不推荐
export function foo() &#123;&#125;
// 推荐
export default function foo() &#123;&#125;</code></pre>
</li>
<li><p>将所有 import 导入放在非导入语句的上面。</p>
<blockquote>
<p>eslint: import/first</p>
</blockquote>
<p>由于 import 被提升，保持他们在顶部，防止意外的行为。</p>
<pre><code class="hljs undefined">// 不推荐
import foo from &apos;foo&apos;;
foo.init();
import bar from &apos;bar&apos;;

// 推荐
import foo from &apos;foo&apos;;
import bar from &apos;bar&apos;;
foo.init();</code></pre>
</li>
<li><p>多行导入应该像多行数组和对象字面量一样进行缩进。</p>
<pre><code class="hljs undefined">// 不推荐
import &#123;longNameA, longNameB, longNameC, longNameD, longNameE&#125; from &apos;path&apos;;
// 推荐
import &#123;
    longNameA,
    longNameB,
    longNameC,
    longNameD,
    longNameE,
&#125; from &apos;path&apos;;</code></pre>
</li>
</ol>
<h2 id="变量-Variables"><a href="#变量-Variables" class="headerlink" title="变量 Variables"></a>变量 Variables</h2><ol>
<li><p>总是使用 const 或 let 来声明变量。 </p>
<p>var 声明变量会导致产生全局变量，避免污染全局命名空间。</p>
<blockquote>
<p>eslint: no-undef prefer-const</p>
</blockquote>
<pre><code class="hljs undefined">// 不推荐
superPower = new SuperPower();
// 推荐
const superPower = new SuperPower();</code></pre>
</li>
<li><p>将所有的 const 和 let 分组 。</p>
<pre><code class="hljs undefined">// 不推荐
let i, len, dragonball,
items = getItems(),
goSportsTeam = true;

// 不推荐
let i;
const items = getItems();
let dragonball;
const goSportsTeam = true;
let len;

// 推荐
const goSportsTeam = true;
const items = getItems();
let dragonball;
let i;
let length;</code></pre>
</li>
<li><p>变量不要链式赋值。</p>
<blockquote>
<p>eslint: no-multi-assign</p>
</blockquote>
<pre><code class="hljs undefined">// 不推荐
(function example() &#123;
  // JavaScript 将其解析为
  // let a = ( b = ( c = 1 ) );
  // let关键字只适用于变量a;
  // 变量b和c变成了全局变量。
  let a = b = c = 1;
&#125;());
console.log(a); // 抛出 ReferenceError（引用错误）
console.log(b); // 1
console.log(c); // 1

// 推荐
(function example() &#123;
  let a = 1;
  let b = a;
  let c = a;
  // 同样适用于 `const`
&#125;());
console.log(a); // 抛出 ReferenceError（引用错误）
console.log(b); // 抛出 ReferenceError（引用错误）
console.log(c); // 抛出 ReferenceError（引用错误）</code></pre>
</li>
<li><p>避免使用一元递增和递减运算符(++, -–)。</p>
<p>根据 eslint 文档，一元递增和递减语句会受到自动插入分号的影响，并可能导致应用程序中的值递增或递减，从而导致无提示错误。</p>
<p>使用像 num += 1 而不是 num++ 或 num ++ 这样的语句来改变你的值也更具有表现力。</p>
<p>不允许一元递增和递减语句也会阻止您无意中预先递增/递减值，这也会导致程序中的意外行为。</p>
<pre><code class="hljs undefined">// 不推荐
const array = [1, 2, 3];
let num = 1;
num++;
--num;
let sum = 0;
let truthyCount = 0;
for (let i = 0; i &lt; array.length; i++) &#123; 
  let value = array[i]; 
  sum += value;
   if (value) &#123;
      truthyCount++; 
    &#125; 
 &#125;

// 推荐
const array = [1, 2, 3]; 
let num = 1; num += 1; num -= 1; 
const sum = array.reduce((a, b) =&gt; a + b, 0);
const truthyCount = array.filter(Boolean).length;</code></pre>
</li>
</ol>
<h2 id="比较运算符-Comparison-Operators-和-等号-Equality"><a href="#比较运算符-Comparison-Operators-和-等号-Equality" class="headerlink" title="比较运算符 Comparison Operators 和 等号 Equality"></a>比较运算符 Comparison Operators 和 等号 Equality</h2><ol>
<li><p>使用 === 和 !== 优先于 == 和 !=。</p>
<blockquote>
<p>eslint: eqeqeq</p>
</blockquote>
</li>
<li><p>对于布尔值使用简写，但对于字符串和数字使用显式比较。</p>
<pre><code class="hljs undefined">// 不推荐
if (isValid === true) &#123;
  // ...
&#125;
// 推荐
if (isValid) &#123;
  // ...
&#125;

// 不推荐
if (name) &#123;
  // ...
&#125;
// 推荐
if (name !== &apos;&apos;) &#123;
  // ...
&#125;

// 不推荐
if (collection.length) &#123;
  // ...
&#125;
// 推荐
if (collection.length &gt; 0) &#123;
  // ...
&#125;</code></pre>
</li>
<li><p>在 case 和 default 子句中，使用大括号来创建包含词法声明的语句块(例如 let, const, function, 和 class).</p>
<blockquote>
<p>eslint: no-case-declarations</p>
</blockquote>
<pre><code class="hljs undefined">// 不推荐
switch (foo) &#123;
  case 1:
    let x = 1;
  break;
  case 2:
    const y = 2;
  break;
  case 3:
    function f() &#123;
      // ...
    &#125;
  break;
default:
  class C &#123;&#125;
&#125;

// 推荐
switch (foo) &#123;
  case 1: &#123;
    let x = 1;
    break;
  &#125;
  case 2: &#123;
    const y = 2;
    break;
  &#125;
  case 3: &#123;
    function f() &#123;
      // ...
    &#125;
    break;
  &#125;
  case 4:
    bar();
    break;
  default: &#123;
    class C &#123;&#125;
  &#125;
&#125;</code></pre>
</li>
<li><p>三元表达式不应该嵌套，通常写成单行表达式。</p>
<blockquote>
<p>eslint: no-nested-ternary</p>
</blockquote>
<pre><code class="hljs undefined">// 不推荐
const foo = maybe1 &gt; maybe2
? &quot;bar&quot;
: value1 &gt; value2 ? &quot;baz&quot; : null;

// 推荐
const maybeNull = value1 &gt; value2 ? &apos;baz&apos; : null;
const foo = maybe1 &gt; maybe2 ? &apos;bar&apos; : maybeNull;</code></pre>
</li>
<li><p>避免不必要的三元表达式语句。</p>
<blockquote>
<p>eslint: no-unneeded-ternary</p>
</blockquote>
<pre><code class="hljs undefined">// 不推荐
const foo = a ? a : b;
const bar = c ? true : false;
const baz = c ? false : true;

// 推荐
const foo = a || b;
const bar = !!c;
const baz = !c;</code></pre>
</li>
<li><p>当运算符混合在一个语句中时，请将其放在括号内。</p>
<blockquote>
<p>eslint: no-mixed-operators</p>
</blockquote>
<p>混合算术运算符时，不要将 * 和 % 与 + ， -，，/ 混合在一起。</p>
<p>提高可读性，并清晰展现开发者的意图。</p>
<pre><code class="hljs undefined">// 不推荐
const foo = a &amp;&amp; b &lt; 0 || c &gt; 0 || d + 1 === 0;
// 不推荐
const bar = a ** b - 5 % d;
// 不推荐
if (a || b &amp;&amp; c) &#123;
  return d;
&#125;
// 推荐
const foo = (a &amp;&amp; b &lt; 0) || c &gt; 0 || (d + 1 === 0);
// 推荐
const bar = (a ** b) - (5 % d);
// 推荐
if ((a || b) &amp;&amp; c) &#123;
  return d;
&#125;
// 推荐
const bar = a + b / c * d;</code></pre>
</li>
</ol>
<h2 id="代码块-Blocks"><a href="#代码块-Blocks" class="headerlink" title="代码块 Blocks"></a>代码块 Blocks</h2><ol>
<li><p>使用大括号包裹所有的多行代码块</p>
<blockquote>
<p>eslint: nonblock-statement-body-position</p>
</blockquote>
<pre><code class="hljs undefined">// 不推荐
if (test)
  return false;
// 推荐
if (test) return false;
// 推荐
if (test) &#123;
  return false;
&#125;

// 不推荐
function foo() &#123; return false; &#125;
// 推荐
function bar() &#123;
  return false;
&#125;</code></pre>
</li>
<li><p>如果通过 if 和 else 使用多行代码块，把 else 放在 if 代码块闭合括号的同一行。</p>
<blockquote>
<p>eslint: brace-style</p>
</blockquote>
<pre><code class="hljs undefined">// 不推荐
if (test) &#123;
  thing1();
  thing2();
&#125;
else &#123;
  thing3();
&#125;

// 推荐
if (test) &#123;
  thing1();
  thing2();
&#125; else &#123;
  thing3();
&#125;</code></pre>
</li>
<li><p>如果一个 if 块总是执行一个 return 语句，后面的 else 块是不必要的。在 else if 块中的 return，可以分成多个 if 块来 return 。</p>
<blockquote>
<p>eslint: no-else-return</p>
</blockquote>
<pre><code class="hljs undefined">// 不推荐
function foo() &#123;
  if (x) &#123;
    return x;
  &#125; else &#123;
    return y;
  &#125;
&#125;
// 不推荐
function cats() &#123;
  if (x) &#123;
    return x;
  &#125; else if (y) &#123;
    return y;
  &#125;
&#125;
// 不推荐
function dogs() &#123;
  if (x) &#123;
    return x;
  &#125; else &#123;
    if (y) &#123;
      return y;
    &#125;
  &#125;
&#125;

// 推荐
function foo() &#123;
  if (x) &#123;
    return x;
  &#125;
  return y;
&#125;
// 推荐
function cats() &#123;
  if (x) &#123;
    return x;
  &#125;
  if (y) &#123;
    return y;
  &#125;
&#125;
// 推荐
function dogs(x) &#123;
  if (x) &#123;
    if (z) &#123;
      return y;
    &#125;
  &#125; else &#123;
    return z;
  &#125;
&#125;</code></pre>
</li>
</ol>
<h2 id="控制语句-Control-Statements"><a href="#控制语句-Control-Statements" class="headerlink" title="控制语句 Control Statements"></a>控制语句 Control Statements</h2><ol>
<li><p>如果控制语句(if, while 的)太长或超过最大行长度，那么每个（分组）条件可以放单独一行。逻辑运算符应该放在每行起始处。</p>
<pre><code class="hljs undefined">// 不推荐
if ((foo === 123 || bar === &apos;abc&apos;) &amp;&amp; doesItLookGoodWhenItBecomesThatLong() &amp;&amp; isThisReallyHappening()) &#123;
 thing1();
&#125;
// 不推荐
if (foo === 123 &amp;&amp;
  bar === &apos;abc&apos;) &#123;
  thing1();
&#125;
// 不推荐
if (foo === 123
  &amp;&amp; bar === &apos;abc&apos;) &#123;
  thing1();
&#125;
// 不推荐
if (
  foo === 123 &amp;&amp;
  bar === &apos;abc&apos;
) &#123;
  thing1();
&#125;

// 推荐
if (
  foo === 123
  &amp;&amp; bar === &apos;abc&apos;
) &#123;
  thing1();
&#125;
// 推荐
if (
  (foo === 123 || bar === &quot;abc&quot;)
  &amp;&amp; doesItLookGoodWhenItBecomesThatLong()
  &amp;&amp; isThisReallyHappening()
) &#123;
  thing1();
&#125;
// 推荐
if (foo === 123 &amp;&amp; bar === &apos;abc&apos;) &#123;
  thing1();
&#125;</code></pre>
</li>
</ol>
<h2 id="注释-Comments"><a href="#注释-Comments" class="headerlink" title="注释 Comments"></a>注释 Comments</h2><ol>
<li><p>多行注释使用 <code>/.../</code>。</p>
<pre><code class="hljs undefined">/**
* @param &#123;Grid&#125; grid 需要合并的Grid
* @param &#123;Array&#125; cols 需要合并列的Index(序号)数组；从0开始计数，序号也包含。
* @param &#123;Boolean&#125; isAllSome 是否2个tr的cols必须完成一样才能进行合并。true：完成一样；false(默认)：不完全一样
* @return void
* @author XXX 2019/09/09
*/
function mergeCells(grid, cols, isAllSome) &#123;
    // Do Something
&#125;</code></pre>
</li>
<li><p>单行注释使用 <code>//</code>。将单行注释放在需注释的语句上方。在注释之前放置一个空行，除非它位于代码块的第一行。</p>
<pre><code class="hljs undefined">// 不推荐
const active = true;  // is current tab
// 推荐
// is current tab
const active = true;

// 不推荐
function getType() &#123;
  console.log(&apos;fetching type...&apos;);
  // set the default type to &apos;no type&apos;
  const type = this.type || &apos;no type&apos;;
  return type;
&#125;
// 推荐
function getType() &#123;
  console.log(&apos;fetching type...&apos;);

  // set the default type to &apos;no type&apos;
  const type = this.type || &apos;no type&apos;;
  return type;
&#125;
// 推荐
function getType() &#123;
  // set the default type to &apos;no type&apos;
  const type = this.type || &apos;no type&apos;;
  return type;
&#125;</code></pre>
</li>
<li><p>所有注释符和注释内容用一个空格隔开，让它更容易阅读。</p>
<blockquote>
<p>eslint: spaced-comment</p>
</blockquote>
<pre><code class="hljs undefined">// 不推荐
//is current tab
const active = true;
// 推荐
// is current tab
const active = true;

// 不推荐
/**
*make() returns a new element
*based on the passed-in tag name
*/
function make(tag) &#123;
  // ...
  return element;
&#125;
// 推荐
/**
* make() returns a new element
* based on the passed-in tag name
*/
function make(tag) &#123;
  // ...
  return element;
&#125;</code></pre>
</li>
<li><p>给注释增加 FIXME 或 TODO 的前缀</p>
<p>帮助其他开发者快速了解这个是否是一个需要重新复查的问题，或是你正在为需要解决的问题提出解决方案。这将有别于常规注释，因为它们是可操作的。</p>
<p>使用 <code>FIXME – need to figure this out</code> 或者 <code>TODO – need to implement</code>。</p>
<p>使用 <code>// FIXME:</code> 来标识需要修正的问题。</p>
<p>注：如果代码中有该标识，说明标识处代码需要修正，甚至代码是错误的，不能工作，需要修复，如何修正会在说明中简略说明。</p>
<pre><code class="hljs undefined">lass Calculator extends Abacus &#123;
  constructor() &#123;
    super();
    // FIXME: shouldn’t use a global here
    total = 0;
  &#125;
&#125;</code></pre>
<p>使用 <code>// TODO:</code> 来标识需要实现的问题。</p>
<p>注：如果代码中有该标识，说明在标识处有功能代码待编写，待实现的功能在说明中会简略说明。</p>
<pre><code class="hljs undefined">class Calculator extends Abacus &#123;
  constructor() &#123;
    super();
    // TODO: total should be configurable by an options param
    this.total = 0;
  &#125;
&#125;</code></pre>
</li>
</ol>
<h2 id="空格-Whitespace"><a href="#空格-Whitespace" class="headerlink" title="空格 Whitespace"></a>空格 Whitespace</h2><ol>
<li><p>使用 2 个空格作为缩进</p>
<pre><code class="hljs undefined">// 推荐
function baz() &#123;
  let name;
&#125;</code></pre>
</li>
<li><p>在大括号前放置 1 个空格。</p>
<blockquote>
<p>eslint: space-before-blocks jscs: requireSpaceBeforeBlockStatements</p>
</blockquote>
<pre><code class="hljs undefined">// 不推荐
function test()&#123;
  console.log(&apos;test&apos;);
&#125;
// 推荐
function test() &#123;
  console.log(&apos;test&apos;);
&#125;
// 不推荐
dog.set(&apos;attr&apos;,&#123;
  age: &apos;1 year&apos;,
  breed: &apos;Bernese Mountain Dog&apos;,
&#125;);
// 推荐
dog.set(&apos;attr&apos;, &#123;
  age: &apos;1 year&apos;,
  breed: &apos;Bernese Mountain Dog&apos;,
&#125;);</code></pre>
</li>
<li><p>在控制语句（if、while 等）的小括号前放一个空格。在函数调用及声明中，不在函数的参数列表前加空格。</p>
<blockquote>
<p>eslint: keyword-spacing jscs: requireSpaceAfterKeywords</p>
</blockquote>
<pre><code class="hljs undefined">// 不推荐
if(isJedi) &#123;
  fight ();
&#125;
// 推荐
if (isJedi) &#123;
  fight();
&#125;

// 不推荐
function fight () &#123;
  console.log (&apos;Swooosh!&apos;);
&#125;
// 推荐
function fight() &#123;
  console.log(&apos;Swooosh!&apos;);
&#125;</code></pre>
</li>
<li><p>使用空格把运算符隔开。</p>
<blockquote>
<p>eslint: space-infix-ops jscs: requireSpaceBeforeBinaryOperators, requireSpaceAfterBinaryOperators</p>
</blockquote>
<pre><code class="hljs undefined">// 不推荐
const x=y+5;
// 推荐
const x = y + 5;</code></pre>
</li>
<li><p>在文件末尾插入一个空行。</p>
<blockquote>
<p>eslint: eol-last</p>
</blockquote>
<pre><code class="hljs undefined">// 不推荐
import &#123; es6 &#125; from &apos;./JavascriptStyleGuide&apos;;
// ...
export default es6;

// 推荐
import &#123; es6 &#125; from &apos;./JavascriptStyleGuide&apos;;
// ...
export default es6;</code></pre>
</li>
<li><p>长方法链式调用时使用缩进（2个以上的方法链式调用）。使用一个点 . 开头，强调该行是一个方法调用，不是一个新的声明。</p>
<blockquote>
<p>eslint: newline-per-chained-call no-whitespace-before-property</p>
</blockquote>
<pre><code class="hljs undefined">// 不推荐
$(&apos;#items&apos;).find(&apos;.selected&apos;).highlight().end().find(&apos;.open&apos;).updateCount();

// 不推荐
$(&apos;#items&apos;).
find(&apos;.selected&apos;).
highlight().
end().
find(&apos;.open&apos;).
updateCount();

// 推荐
$(&apos;#items&apos;)
  .find(&apos;.selected&apos;)
  .highlight()
  .end()
  .find(&apos;.open&apos;)
  .updateCount();

// 不推荐
const leds = stage.selectAll(&apos;.led&apos;).data(data).enter().append(&apos;svg:svg&apos;).classed(&apos;led&apos;, true)
.attr(&apos;width&apos;, (radius + margin) * 2).append(&apos;svg:g&apos;)
.attr(&apos;transform&apos;, `translate($&#123;radius + margin&#125;,$&#123;radius + margin&#125;)`)
.call(tron.led);

// 推荐
const leds = stage.selectAll(&apos;.led&apos;)
  .data(data)
  .enter().append(&apos;svg:svg&apos;)
  .classed(&apos;led&apos;, true)
  .attr(&apos;width&apos;, (radius + margin) * 2)
  .append(&apos;svg:g&apos;)
  .attr(&apos;transform&apos;, `translate($&#123;radius + margin&#125;,$&#123;radius + margin&#125;)`)
  .call(tron.led);
// 推荐
const leds = stage.selectAll(&apos;.led&apos;).data(data);</code></pre>
</li>
<li><p>不要在圆括号内加空格。</p>
<pre><code class="hljs undefined">// 不推荐
function bar( foo ) &#123;
  return foo;
&#125;
// 推荐
function bar(foo) &#123;
  return foo;
&#125;
// 不推荐
if ( foo ) &#123;
  console.log(foo);
&#125;
// 推荐
if (foo) &#123;
  console.log(foo);
&#125;</code></pre>
</li>
<li><p>不要在中括号内添加空格。</p>
<blockquote>
<p>eslint: array-bracket-spacing jscs: disallowSpacesInsideArrayBrackets</p>
</blockquote>
<pre><code class="hljs undefined">// 不推荐
const foo = [ 1, 2, 3 ];
console.log(foo[ 0 ]);
// 推荐
const foo = [1, 2, 3];
console.log(foo[0]);</code></pre>
</li>
<li><p>在大括号内添加空格</p>
<pre><code class="hljs undefined">// 不推荐
const foo = &#123;clark: &apos;kent&apos;&#125;;
// 推荐
const foo = &#123; clark: &apos;kent&apos; &#125;;</code></pre>
</li>
</ol>
<h2 id="类型转换-Type-Casting-amp-Coercion"><a href="#类型转换-Type-Casting-amp-Coercion" class="headerlink" title="类型转换 Type Casting &amp; Coercion"></a>类型转换 Type Casting &amp; Coercion</h2><ol>
<li><p>在声明语句的开始处就执行强制类型转换.</p>
<p>字符串：</p>
<blockquote>
<p>eslint: no-new-wrappers</p>
</blockquote>
<pre><code class="hljs undefined">// =&gt; this.reviewScore = 9;
// 不推荐
const totalScore = new String(this.reviewScore); // typeof totalScore 是 &quot;object&quot; 而不是 &quot;string&quot;
// 不推荐
const totalScore = this.reviewScore + &apos;&apos;; // 调用 this.reviewScore.valueOf()
// 不推荐
const totalScore = this.reviewScore.toString(); // 不能保证返回一个字符串
// 推荐
const totalScore = String(this.reviewScore);</code></pre>
<p>数字：使用 Number 进行转换，而 parseInt 则始终以基数解析字串。</p>
<blockquote>
<p>eslint: radix no-new-wrappers</p>
</blockquote>
<pre><code class="hljs undefined">const inputValue = &apos;4&apos;;
// 不推荐
const val = new Number(inputValue);
// 不推荐
const val = +inputValue;
// 不推荐
const val = inputValue &gt;&gt; 0;
// 不推荐
const val = parseInt(inputValue);
// 推荐
const val = Number(inputValue);
// 推荐
const val = parseInt(inputValue, 10);</code></pre>
<p>布尔值:</p>
<blockquote>
<p>eslint: no-new-wrappers</p>
</blockquote>
<pre><code class="hljs undefined">const age = 0;
// 不推荐
const hasAge = new Boolean(age);
// 推荐
const hasAge = Boolean(age);
// 强烈推荐
const hasAge = !!age;</code></pre>
</li>
</ol>
<h2 id="命名规则-Naming-Conventions"><a href="#命名规则-Naming-Conventions" class="headerlink" title="命名规则 Naming Conventions"></a>命名规则 Naming Conventions</h2><ol>
<li><p>避免使用单字母名称，命名应具有描述性。</p>
<blockquote>
<p>eslint: id-length</p>
</blockquote>
<pre><code class="hljs undefined">// 不推荐
function q() &#123;
  // ...
&#125;
// 推荐
function query() &#123;
  // ...
&#125;</code></pre>
</li>
<li><p>当命名对象，函数和实例时使用驼峰式命名。</p>
<blockquote>
<p>eslint: camelcase jscs: requireCamelCaseOrUpperCaseIdentifiers</p>
</blockquote>
<pre><code class="hljs undefined">// 不推荐
const OBJEcttsssss = &#123;&#125;;
const this_is_my_object = &#123;&#125;;
function c() &#123;&#125;
// 推荐
const thisIsMyObject = &#123;&#125;;
function thisIsMyFunction() &#123;&#125;</code></pre>
</li>
<li><p>当命名构造函数或类的时候使用 PascalCase 式命名，（注：即单词首字母大写）。</p>
<blockquote>
<p>eslint: new-cap</p>
</blockquote>
<pre><code class="hljs undefined">// 不推荐
function user(options) &#123;
  this.name = options.name;
&#125;
const bad = new user(&#123;
  name: &apos;nope&apos;,
&#125;);
// 推荐
class User &#123;
  constructor(options) &#123;
    this.name = options.name;
  &#125;
&#125;
const good = new User(&#123;
  name: &apos;yup&apos;,
&#125;);</code></pre>
</li>
<li><p>当导出(export) 一个默认函数时使用驼峰式命名。你的文件名应该和你的函数的名字一致。</p>
<pre><code class="hljs undefined">function makeStyleGuide() &#123;
  // ...
&#125;
export default makeStyleGuide;</code></pre>
</li>
<li><p>当导出一个构造函数/类/单例/函数库/纯对象时使用 PascalCase 式命名。</p>
<pre><code class="hljs undefined">const JavascriptStyleGuide = &#123;
  es6: &#123;
  &#125;,
&#125;;
export default JavascriptStyleGuide;</code></pre>
</li>
</ol>
<h2 id="存取器-Accessors"><a href="#存取器-Accessors" class="headerlink" title="存取器 Accessors"></a>存取器 Accessors</h2><p>属性的存取器函数不是必须的。</p>
<ol>
<li><p>別使用 JavaScript 的 getters/setters，因为它们会导致意想不到的副作用，而且很难测试，维护和理解。相反，如果要使用存取器函数，使用 getVal() 及 setVal(‘hello’)。</p>
<pre><code class="hljs undefined">// 不推荐
class Dragon &#123;
  get age() &#123;
    // ...
  &#125;
  set age(value) &#123;
    // ...
  &#125;
&#125;
// 推荐
class Dragon &#123;
  getAge() &#123;
    // ...
  &#125;
  setAge(value) &#123;
    // ...
  &#125;
&#125;</code></pre>
</li>
<li><p>如果属性/方法是一个 boolean, 使用 isVal() 或 hasVal() 方法。</p>
<pre><code class="hljs undefined">// 不推荐
if (!dragon.age()) &#123;
  return false;
&#125;
// 推荐
if (!dragon.hasAge()) &#123;
  return false;
&#125;</code></pre>
</li>
</ol>
<h2 id="摘自文章"><a href="#摘自文章" class="headerlink" title="摘自文章"></a>摘自文章</h2><ul>
<li><a href="https://cloud.tencent.com/developer/article/1404290" target="_blank" rel="noopener">JavaScript 编程规范(一)</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1404381" target="_blank" rel="noopener">JavaScript 编程规范(二)</a></li>
</ul>

  
  
  <div class="footer" style="display:none;">
      <script src="//m.servedby-buysellads.com/monetization.js" type="text/javascript"></script>
<div class="bsa-cpc"></div>
<script>
  (function(){
    if(typeof _bsa !== 'undefined' && _bsa) {
    _bsa.init('default', 'CKYD62QM', 'placement:vuejsorg', {
      target: '.bsa-cpc',
      align: 'horizontal',
      disable_css: 'true'
    });
      }
  })();
</script>

    发现错误？想参与编辑？
    <a href="https://github.com/vuejs/cn.vuejs.org/blob/master/src/developer/style-guide/javascript.md" target="_blank">
      在 GitHub 上编辑此页！
    </a>
  </div>
</div>

        
      </div>
      <script src="/js/smooth-scroll.min.js"></script>
    

    <!-- main custom script for sidebars, version selects etc. -->
    <script src="/js/css.escape.js"></script>
    <script src="/js/common.js"></script>

    <!-- search -->
    <link href="//code.bdstatic.com/npm/docsearch.js@1.5.0/dist/cdn/docsearch.min.css" rel="stylesheet" type="text/css">
    <link rel="stylesheet" href="/css/search.css">
    <script src="//code.bdstatic.com/npm/docsearch.js@1.5.0/dist/cdn/docsearch.min.js"></script>
    <script>
    [
      '#search-query-nav',
      '#search-query-sidebar',
      '#search-query-menu'
    ].forEach(function (selector) {
      if (!document.querySelector(selector)) return
      // search index defaults to v2
      var match = window.location.pathname.match(/^\/(v\d+)/)
      var version = match ? match[1] : 'v2'
      docsearch({
      appId: 'BH4D9OD16A',
      apiKey: '5638280abff9d207417bb03be05f0b25',
      indexName: 'vuejs_cn2',
      inputSelector: selector,
      algoliaOptions: { facetFilters: ["version:" + version] },
      autocompleteOptions: { hint: false, appendTo: 'body'}
      })
    })
    </script>

    <!-- fastclick -->
    <script src="//code.bdstatic.com/npm/fastclick@1.0.6/lib/fastclick.js"></script>
    <script>
    document.addEventListener('DOMContentLoaded', function() {
      FastClick.attach(document.body)
    }, false)
    </script>
  </body>
</html>
